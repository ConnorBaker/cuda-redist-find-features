# NOTE:
# Make sure to run `nix run .#stage0 && git add .` prior to this script.
{
  cuda-redist-feature-detector,
  jq,
  lib,
  nixVersions,
  pkgs,
  writers,
  writeShellApplication,
}:
let
  inherit
    ((lib.modules.evalModules {
      specialArgs = {
        inherit pkgs;
      };
      modules = [ ../../modules/stages/stage1a.nix ];
    }).config
    )
    stages
    ;
  indexOfHashesJSON = stages.stage0.outputPath;
  hashToUnpackedStorePathJSON = writers.writeJSON "stage1a-hash-to-unpacked-store-path.json" stages.stage1a.result;
  jqFilter = writers.writeText "jq-filter.jq" ''
    walk(
      if type == "string" and in($hashToUnpackedStorePath[0]) then
        # If it is in hashToUnpackedStorePath, then it must be a tarball hash.
        . as $hash |
        # Get the unpacked store path, which we use to get the feature and nar hash.
        $hashToUnpackedStorePath[0][$hash] as $unpackedStorePath |
        $unpackedStorePathToFeature[0][$unpackedStorePath] as $feature |
        $unpackedStorePathToNarHash[0][$unpackedStorePath] as $narHash |
        # Replace the hash of the tarball with the nar hash mapped to the feature.
        { $narHash: $feature }
      else
        # Otherwise, just return the value.
        .
      end
    )
  '';
in
writeShellApplication {
  name = "generate-aggregate-unpacked-src-out-path-to-nar-hash";
  runtimeInputs = [
    cuda-redist-feature-detector
    jq
    nixVersions.unstable
  ];
  runtimeEnv = {
    JQ_COMMON_FLAGS = [
      # "--compact-output"
      "--sort-keys"
      "--raw-output"
    ];
  };
  derivationArgs = {
    __contentAddressed = true;
    __structuredAttrs = true;
    strictDeps = true;

    preferLocalBuild = true;
    allowSubstitutes = false;
  };
  text = ''
    hashToUnpackedStorePathJSONPath="${hashToUnpackedStorePathJSON.name}"
    unpackedStorePathToNarHashJSONPath="stage1a-unpacked-store-path-to-nar-hash.json"
    unpackedStorePathToFeatureJSONPath="stage1a-unpacked-store-path-to-feature.json"

    cat < "${hashToUnpackedStorePathJSON}" > "$hashToUnpackedStorePathJSONPath"

    echo "Acquiring NAR hashes for store paths in $hashToUnpackedStorePathJSONPath"
    jq "''${JQ_COMMON_FLAGS[@]}" '.[]' "$hashToUnpackedStorePathJSONPath" \
      | nix path-info --quiet --json --stdin \
      | jq "''${JQ_COMMON_FLAGS[@]}" 'with_entries(.value |= .narHash)' \
      > "$unpackedStorePathToNarHashJSONPath"

    echo "Acquiring features for store paths in $hashToUnpackedStorePathJSONPath"
    jq "''${JQ_COMMON_FLAGS[@]}" '.[]' "$hashToUnpackedStorePathJSONPath" \
      | cuda-redist-feature-detector --stdin \
      > "$unpackedStorePathToFeatureJSONPath"

    echo "Joining the store the results"
    jq "''${JQ_COMMON_FLAGS[@]}" --from-file "${jqFilter}" "${indexOfHashesJSON}" \
      --slurpfile hashToUnpackedStorePath "$hashToUnpackedStorePathJSONPath" \
      --slurpfile unpackedStorePathToFeature "$unpackedStorePathToFeatureJSONPath" \
      --slurpfile unpackedStorePathToNarHash "$unpackedStorePathToNarHashJSONPath" \
      > "${stages.stage1a.outputPath}"
  '';
}
